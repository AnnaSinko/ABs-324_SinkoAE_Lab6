package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // инициализация генератора случайных чисел текущим временем

	var M, N int // объявление переменных для количества строк и столбцов матрицы
	fmt.Print("Введите количество строк (M): ") // вывод сообщения на экран о необходимости ввести количество строк
	fmt.Scan(&M) // ввод количества строк с клавиатуры
	fmt.Print("Введите количество столбцов (N): ") // вывод сообщения на экран о необходимости ввести количество столбцов
	fmt.Scan(&N) // ввод количества столбцов с клавиатуры

	matrix := make([][]int, M) // объявление двумерного вектора (матрицы) размером M x N
	for i := range matrix {
		matrix[i] = make([]int, N)
	}

	sequences := make(map[int][]int) // объявление словаря для хранения найденных последовательностей

	// Заполнение матрицы случайными числами
	for i := 0; i < M; i++ { // цикл по строкам матрицы
		for j := 0; j < N; j++ { // цикл по столбцам матрицы
			matrix[i][j] = rand.Intn(101) // заполнение матрицы случайными числами от 0 до 100 (по условию)
		}
	}

	// Нахождение возрастающих последовательностей в каждой строке
	for i := 0; i < M; i++ { // цикл по строкам матрицы
		start := 0 // начальный индекс текущей последовательности
		for j := 1; j < N; j++ { // цикл по столбцам матрицы
			if matrix[i][j] <= matrix[i][j-1] { // если текущий элемент меньше предыдущего
				if j-start > 1 { // если длина текущей последовательности больше 1
					sequence := make([]int, j-start)
					copy(sequence, matrix[i][start:j])
					sequences[matrix[i][start]] = sequence // добавление последовательности в словарь
				}
				start = j // обновление начала текущей последовательности
			}
		}
		if N-start > 1 { // если длина последней последовательности больше 1
			sequence := make([]int, N-start)
			copy(sequence, matrix[i][start:])
			sequences[matrix[i][start]] = sequence // добавление последней последовательности в словарь
		}
	}

	// Вывод начальной матрицы на экран
	fmt.Println("Матрица:") // вывод сообщения на экран
	for i := 0; i < M; i++ { // цикл по строкам матрицы
		for j := 0; j < N; j++ { // цикл по столбцам матрицы
			fmt.Print(matrix[i][j], " ") // вывод элемента матрицы на экран
		}
		fmt.Println() // переход на новую строку
	}

	// Вывод найденных последовательностей на экран
	fmt.Println("Найденные последовательности:") // вывод сообщения на экран
	for _, sequence := range sequences { // цикл по всем последовательностям в словаре
		for _, num := range sequence { // цикл по элементам текущей последовательности
			fmt.Print(num, " ") // вывод элемента последовательности на экран
		}
		fmt.Println() // переход на новую строку
	}
}